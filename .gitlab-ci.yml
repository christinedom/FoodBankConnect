stages:
  - build
  - deploy         
  - backend_release 
  - backend_test    
  - selenium_tests
  - jest_tests

# ------------------------------------------------
# GLOBAL ENVIRONMENT VARIABLES
# ------------------------------------------------
variables:
  REQUIREMENTS_FILE_UNIT: "fbc-load-db/requirements.txt"
  REQUIREMENTS_FILE_API:  "fbc-rest-api/requirements.txt"

  PYTEST_WORKDIR: ""
  PYTEST_TESTPATH: "tests"
  PYTEST_IGNORE: "frontend/src/selenium_tests"

  REPORT_DIR: "reports"
  PYTEST_JUNIT_XML: "$REPORT_DIR/pytest-report.xml"
  PYTEST_COVERAGE_XML: "$REPORT_DIR/coverage.xml"

  POSTMAN_COLLECTION: "tests/postman/collection.json"
  NEWMAN_JUNIT_XML: "$REPORT_DIR/newman-results.xml"

  API_APP_ENTRY: "fbc-rest-api/main.py"
  API_HEALTH_URL: "http://localhost:8080/health"

  COV_TARGET_DIR: "fbc-load-db"

# ------------------------------------------------
# Frontend build and deploy remain the same
# ------------------------------------------------
build_react:
  stage: build
  image: node:20-bullseye
  script:
    - cd frontend
    - npm ci
    - CI=false npm run build
  artifacts:
    paths:
      - frontend/build
  rules:
    # Allow override via variable in the UI or API
    - if: '$FORCE_FRONTEND == "1"'
      when: on_success

    # Build only if relevant files changed
    - changes:
        - frontend/**/*  
        - frontend/.env*      
        - package.json         
        - package-lock.json
        - frontend/package.json  
        - frontend/package-lock.json
      when: on_success

    # Default: skip
    - when: never


deploy_website:
  stage: deploy
  image:
    name: amazon/aws-cli
    entrypoint: [""]
  dependencies:
    - build_react
  script:
    - aws s3 sync frontend/build/ s3://$S3_BUCKET --delete
    - aws cloudfront create-invalidation --distribution-id $CLOUDFRONT_DIST_ID --paths "/*"
  rules:
    # Allow manual forcing
    - if: '$FORCE_FRONTEND == "1" && $CI_COMMIT_BRANCH == "main"'
      when: on_success

    # Deploy only on main when frontend changed (i.e., build ran)
    - if: '$CI_COMMIT_BRANCH == "main"'
      changes:
        - frontend/**/*
        - frontend/.env*
        - package.json
        - package-lock.json
        - frontend/package.json
        - frontend/package-lock.json
      when: on_success

    # Default: skip
    - when: never

# ------------------------------
# Backend Release: build & push 2 images, update Lambda, start Batch — non-blocking and AFTER deploy
# ------------------------------
backend_release:
  stage: backend_release
  image: docker:24.0.7
  needs: []
  services:
    - name: docker:24.0.7-dind
      alias: docker
      command: ["--tls=false","--mtu=1460"]
  allow_failure: true
  variables:
    DOCKER_HOST: "tcp://docker:2375"
    DOCKER_TLS_CERTDIR: ""
    # AWS (set in GitLab CI variables)
    AWS_DEFAULT_REGION: $AWS_DEFAULT_REGION
    AWS_ACCESS_KEY_ID: $AWS_ACCESS_KEY_ID
    AWS_SECRET_ACCESS_KEY: $AWS_SECRET_ACCESS_KEY
    # ECR
    ECR_REGISTRY: $ECR_REGISTRY
    ECR_REPO_API: $ECR_REPO_API
    ECR_REPO_LOADER: $ECR_REPO_LOADER
    IMAGE_TAG: $CI_COMMIT_SHORT_SHA
    # Lambda
    LAMBDA_FUNCTION_NAME: $LAMBDA_FUNCTION_NAME
    # Batch
    BATCH_JOB_QUEUE: $BATCH_JOB_QUEUE
    BATCH_JOB_DEFINITION: $BATCH_JOB_DEFINITION
    BATCH_JOB_NAME: $BATCH_JOB_NAME
    # Docker build paths (override if needed)
    API_CONTEXT: "."
    API_DOCKERFILE: "Dockerfile.api"
    LOADER_CONTEXT: "."
    LOADER_DOCKERFILE: "Dockerfile.loader"
  before_script:
    - apk add --no-cache curl bash jq aws-cli
    - aws --version
    - >
      aws ecr get-login-password --region "$AWS_DEFAULT_REGION" |
      docker login --username AWS --password-stdin "$ECR_REGISTRY"

  script:
    - >
      set -e;
      echo "Building API image…";
      docker build -f "$API_DOCKERFILE" -t "$ECR_REGISTRY/$ECR_REPO_API:$IMAGE_TAG" "$API_CONTEXT";
      docker push "$ECR_REGISTRY/$ECR_REPO_API:$IMAGE_TAG";
      if [ "$CI_COMMIT_BRANCH" = "main" ]; then
        docker tag "$ECR_REGISTRY/$ECR_REPO_API:$IMAGE_TAG" "$ECR_REGISTRY/$ECR_REPO_API:latest";
        docker push "$ECR_REGISTRY/$ECR_REPO_API:latest";
      fi
    - >
      set -e;
      echo "Building Loader image…";
      docker build -f "$LOADER_DOCKERFILE" -t "$ECR_REGISTRY/$ECR_REPO_LOADER:$IMAGE_TAG" "$LOADER_CONTEXT";
      docker push "$ECR_REGISTRY/$ECR_REPO_LOADER:$IMAGE_TAG";
      if [ "$CI_COMMIT_BRANCH" = "main" ]; then
        docker tag "$ECR_REGISTRY/$ECR_REPO_LOADER:$IMAGE_TAG" "$ECR_REGISTRY/$ECR_REPO_LOADER:latest";
        docker push "$ECR_REGISTRY/$ECR_REPO_LOADER:latest";
      fi
    - >
      set -e;
      echo "Updating Lambda function image…";
      aws lambda update-function-code
      --function-name "$LAMBDA_FUNCTION_NAME"
      --image-uri "$ECR_REGISTRY/$ECR_REPO_API:$IMAGE_TAG"
      --region "$AWS_DEFAULT_REGION"
      | jq -r '.LastUpdateStatus, .StateReason // empty'
    - |
      set -e
      echo "Waiting for Lambda to be Active (~2min max)…"
      for i in {1..24}; do
        STATUS=$(aws lambda get-function-configuration \
          --function-name "$LAMBDA_FUNCTION_NAME" \
          --region "$AWS_DEFAULT_REGION" | jq -r '.State')
        echo "Lambda state: $STATUS"
        [ "$STATUS" = "Active" ] && break
        sleep 5
      done
    - >
      set -e;
      echo "Submitting AWS Batch job…";
      aws batch submit-job
      --job-name "${BATCH_JOB_NAME:-fbc-refill-$CI_COMMIT_SHORT_SHA}"
      --job-queue "$BATCH_JOB_QUEUE"
      --job-definition "$BATCH_JOB_DEFINITION"
      --region "$AWS_DEFAULT_REGION"
      --container-overrides 'environment=[]'
      | tee batch_submit.json;
      echo "Batch job submitted: $(jq -r .jobId batch_submit.json)"
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
      when: on_success
    - if: '$CI_COMMIT_TAG'
      when: on_success
    - when: never


# ------------------------------------------------
# Backend: Unit tests with pytest
# ------------------------------------------------
backend_unit_tests:
  stage: backend_test
  image: python:3.12-bullseye
  needs: []
  before_script:
    - python -V
    - pip install -r "$REQUIREMENTS_FILE_UNIT"
    - pip install pytest pytest-cov
    - mkdir -p "$CI_PROJECT_DIR/$REPORT_DIR"
    # --- CLEAN TEST TABLES ---
    - python - <<'PY'
        import os, ssl, pg8000
        schema = os.getenv("DB_SCHEMA", "app_ci_test")
        conn = pg8000.connect(
            host=os.environ["DB_HOST"],
            user=os.environ["DB_USER"],
            password=os.environ["DB_PASSWORD"],
            database=os.environ["DB_NAME"],
            ssl_context=ssl.create_default_context()
        )
        cur = conn.cursor()
        cur.execute(f"TRUNCATE {schema}.programs, {schema}.sponsors, {schema}.foodbanks RESTART IDENTITY CASCADE;")
        conn.commit()
        conn.close()
        print("[ci] truncated test tables")
        PY
  script:
    - |
      export PYTHONPATH="$CI_PROJECT_DIR/$COV_TARGET_DIR:$PYTHONPATH"
      pytest -q --maxfail=1 --disable-warnings \
        --ignore="$CI_PROJECT_DIR/$PYTEST_IGNORE" \
        "$CI_PROJECT_DIR/$PYTEST_TESTPATH" \
        --cov="$CI_PROJECT_DIR/$COV_TARGET_DIR" \
        --cov-report=xml:"$CI_PROJECT_DIR/$PYTEST_COVERAGE_XML" \
        --junitxml "$CI_PROJECT_DIR/$PYTEST_JUNIT_XML"



# ------------------------------------------------
# Backend: API tests with Newman/Postman
# ------------------------------------------------
backend_api_tests:
  stage: backend_test
  image: node:20-bullseye
  needs: []
  before_script:
    - apt-get update && apt-get install -y python3 python3-pip curl
    - pip install -r "$REQUIREMENTS_FILE_API"
    - npm install -g newman
    - mkdir -p "$CI_PROJECT_DIR/$REPORT_DIR"
  script:
    # Start your API app if it exists
    - |
      if [ -f "$API_APP_ENTRY" ]; then
        python3 "$API_APP_ENTRY" & echo $! > flask.pid
        for i in {1..60}; do curl -sf "$API_HEALTH_URL" && break; sleep 1; done || true
      fi

    # Run collection and always write the JUnit file where artifacts expect it
    - newman run "$POSTMAN_COLLECTION" \
        --reporters cli,junit \
        --reporter-junit-export "$CI_PROJECT_DIR/$NEWMAN_JUNIT_XML" || NEWMAN_RC=$?

    # Cleanup and ensure artifact exists
    - if [ -f flask.pid ]; then kill "$(cat flask.pid)" || true; fi
    - if [ ! -s "$CI_PROJECT_DIR/$NEWMAN_JUNIT_XML" ]; then echo "<testsuite></testsuite>" > "$CI_PROJECT_DIR/$NEWMAN_JUNIT_XML"; fi
    - exit ${NEWMAN_RC:-0}
  artifacts:
    when: always
    reports:
      junit: $NEWMAN_JUNIT_XML
    paths:
      - $NEWMAN_JUNIT_XML
  rules:
    - when: on_success



# ------------------------------------------------
# Frontend tests: Tests with selenium
# ------------------------------------------------
selenium_tests:
  stage: selenium_tests
  image: python:3.12-bullseye
  before_script:
    - apt-get update && apt-get install -y wget unzip xvfb libxi6 libgconf-2-4 gnupg
    # Install Google Chrome
    - wget -q -O - https://dl.google.com/linux/linux_signing_key.pub | apt-key add -
    - echo "deb [arch=amd64] http://dl.google.com/linux/chrome/deb/ stable main" > /etc/apt/sources.list.d/google-chrome.list
    - apt-get update && apt-get install -y google-chrome-stable
    # Match ChromeDriver to Chrome major version
    - CHROME_VERSION=$(google-chrome --version | grep -oP '\d+\.\d+\.\d+')
    - wget -q "https://chromedriver.storage.googleapis.com/$CHROME_VERSION/chromedriver_linux64.zip"
    - unzip chromedriver_linux64.zip
    - mv chromedriver /usr/local/bin/
    - chmod +x /usr/local/bin/chromedriver
    # Python deps for Selenium tests
    - pip install -r "frontend/tests/requirements.txt"
    - pip install pytest
  script:
    - cd frontend/src/selenium_tests
    - python -m pytest -q --maxfail=1 --disable-warnings \
        --junitxml "$CI_PROJECT_DIR/reports/selenium-junit.xml"
  artifacts:
    when: always
    reports:
      junit: reports/selenium-junit.xml
    paths:
      - reports/selenium-junit.xml
  rules:
    - changes:
        - frontend/src/selenium_tests/**/*
        - frontend/tests/requirements.txt
      when: on_success
    - when: never



# ------------------------------------------------
# Frontend tests: Tests with Jest
# ------------------------------------------------
jest_tests:
  stage: jest_tests
  image: node:20-bullseye
  before_script:
    - cd frontend
  script:
    - npm ci
    - npm test -- --watchAll=false
  rules:
    - changes:
        - frontend/src/__tests__/**/*
        - frontend/package.json
        - frontend/package-lock.json
      when: on_success
    - when: never