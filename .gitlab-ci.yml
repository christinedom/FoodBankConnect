stages:
  - build
  - deploy         
  - backend_test    
  - backend_release 
  - selenium_tests

# ------------------------------
# Frontend: Build React
# ------------------------------
build_react:
  stage: build
  image: node:20-bullseye
  script:
    - cd frontend
    - npm ci
    - CI=false npm run build
  artifacts:
    paths:
      - frontend/build
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
      when: on_success
    - when: never

# ------------------------------
# Frontend: Deploy to S3 + CloudFront
# ------------------------------
deploy_website:
  stage: deploy
  image:
    name: amazon/aws-cli
    entrypoint: [""]
  script:
    - aws s3 sync frontend/build/ s3://$S3_BUCKET --delete
    - aws cloudfront create-invalidation --distribution-id $CLOUDFRONT_DIST_ID --paths "/*"
  dependencies:
    - build_react
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
      when: on_success
    - when: never

# ------------------------------
# Backend: Python unit tests (pytest) — non-blocking and AFTER deploy
# ------------------------------
backend_unit_tests:
  stage: backend_test
  image: python:3.11
  needs: ["backend_deploy"]
  allow_failure: true                   # never block anything
  services:
    - name: postgres:15
      alias: postgres
      command: ["postgres","-c","fsync=off","-c","full_page_writes=off","-c","synchronous_commit=off"]
  variables:
    PIP_DISABLE_PIP_VERSION_CHECK: "1"
    PYTHONDONTWRITEBYTECODE: "1"
    PYTHONUNBUFFERED: "1"
    FLASK_ENV: "production"
    PORT: "8080"
    DB_HOST: "postgres"
    DB_PORT: "5432"
    DB_USER: "postgres"
    DB_PASSWORD: "postgres"
    DB_NAME: "postgres"
    DB_SCHEMA: "app"
    POSTGRES_DB: postgres
    POSTGRES_USER: postgres
    POSTGRES_PASSWORD: postgres
  before_script:
    - python -V
    - pip install -r requirements.txt
    - pip install pytest pytest-cov
    # Wait for Postgres
    - for i in {1..30}; do pg_isready -h postgres -p 5432 && break; sleep 1; done || (echo "Postgres not ready" && exit 1)
  script:
    - pytest -q --maxfail=1 --disable-warnings --cov=./ --cov-report=xml:coverage.xml --junitxml=pytest-report.xml
  artifacts:
    when: always
    reports:
      junit: pytest-report.xml
      coverage_report:
        coverage_format: cobertura
        path: coverage.xml
    paths:
      - pytest-report.xml
      - coverage.xml
  rules:
    - changes:
        - main.py
        - scraper.py
        - requirements.txt
        - tests/**/*         # your pytest tree
      when: on_success
    - when: never

# ------------------------------
# Backend: API tests (start Flask + run Postman via Newman) — non-blocking and AFTER deploy
# ------------------------------
backend_api_tests:
  stage: backend_test
  image: node:20
  allow_failure: true                   # never block anything
  needs: ["backend_deploy"]
  services:
    - name: postgres:15
      alias: postgres
      command: ["postgres","-c","fsync=off","-c","full_page_writes=off","-c","synchronous_commit=off"]
  variables:
    FLASK_ENV: "production"
    PORT: "8080"
    DB_HOST: "postgres"
    DB_PORT: "5432"
    DB_USER: "postgres"
    DB_PASSWORD: "postgres"
    DB_NAME: "postgres"
    DB_SCHEMA: "app"
    POSTGRES_DB: postgres
    POSTGRES_USER: postgres
    POSTGRES_PASSWORD: postgres
  before_script:
    - apt-get update && apt-get install -y python3 python3-pip curl
    - pip install -r requirements.txt
    - npm install -g newman
    # Wait for Postgres socket using a safe heredoc inside a block scalar
    - |
      for i in {1..30}; do
        python3 - <<'PY'
        import socket, sys
        s = socket.socket()
        s.settimeout(1)
        try:
            s.connect(('postgres', 5432))
            print("ok")
            sys.exit(0)
        except Exception:
            sys.exit(1)
        finally:
            s.close()
        PY
        [ $? -eq 0 ] && break
        sleep 1
      done
  script:
    # Start Flask app in background
    - python3 main.py & echo $! > flask.pid
    # Wait for health endpoint
    - for i in {1..60}; do curl -sf http://localhost:8080/health && break; sleep 1; done
    # Run Postman collection
    - newman run tests/postman/collection.json --env-var BASE_URL=http://localhost:8080 --reporters cli,junit --reporter-junit-export newman-results.xml
  after_script:
    - if [ -f flask.pid ]; then kill $(cat flask.pid) || true; fi
  artifacts:
    when: always
    reports:
      junit: newman-results.xml
    paths:
      - newman-results.xml
  rules:
    - changes:
        - main.py
        - scraper.py
        - requirements.txt
        - tests/postman/**/*  # your postman/newman files
      when: on_success
    - when: never

# ------------------------------
# Backend Release: build & push 2 images, update Lambda, start Batch — non-blocking and AFTER deploy
# ------------------------------
backend_release:
  stage: backend_release
  image: docker:24.0.7
  needs: []
  services:
    - name: docker:24.0.7-dind
      alias: docker
      command: ["--tls=false","--mtu=1460"]
  allow_failure: true
  variables:
    DOCKER_HOST: "tcp://docker:2375"
    DOCKER_TLS_CERTDIR: ""
    # AWS (set in GitLab CI variables)
    AWS_DEFAULT_REGION: $AWS_DEFAULT_REGION
    AWS_ACCESS_KEY_ID: $AWS_ACCESS_KEY_ID
    AWS_SECRET_ACCESS_KEY: $AWS_SECRET_ACCESS_KEY
    # ECR
    ECR_REGISTRY: $ECR_REGISTRY
    ECR_REPO_API: $ECR_REPO_API
    ECR_REPO_LOADER: $ECR_REPO_LOADER
    IMAGE_TAG: $CI_COMMIT_SHORT_SHA
    # Lambda
    LAMBDA_FUNCTION_NAME: $LAMBDA_FUNCTION_NAME
    # Batch
    BATCH_JOB_QUEUE: $BATCH_JOB_QUEUE
    BATCH_JOB_DEFINITION: $BATCH_JOB_DEFINITION
    BATCH_JOB_NAME: $BATCH_JOB_NAME
    # Docker build paths (override if needed)
    API_CONTEXT: "."
    API_DOCKERFILE: "Dockerfile.api"
    LOADER_CONTEXT: "."
    LOADER_DOCKERFILE: "Dockerfile.loader"
  before_script:
    - apk add --no-cache curl bash jq aws-cli
    - aws --version
    - >
      aws ecr get-login-password --region "$AWS_DEFAULT_REGION" |
      docker login --username AWS --password-stdin "$ECR_REGISTRY"

  script:
    - >
      set -e;
      echo "Building API image…";
      docker build -f "$API_DOCKERFILE" -t "$ECR_REGISTRY/$ECR_REPO_API:$IMAGE_TAG" "$API_CONTEXT";
      docker push "$ECR_REGISTRY/$ECR_REPO_API:$IMAGE_TAG";
      if [ "$CI_COMMIT_BRANCH" = "main" ]; then
        docker tag "$ECR_REGISTRY/$ECR_REPO_API:$IMAGE_TAG" "$ECR_REGISTRY/$ECR_REPO_API:latest";
        docker push "$ECR_REGISTRY/$ECR_REPO_API:latest";
      fi
    - >
      set -e;
      echo "Building Loader image…";
      docker build -f "$LOADER_DOCKERFILE" -t "$ECR_REGISTRY/$ECR_REPO_LOADER:$IMAGE_TAG" "$LOADER_CONTEXT";
      docker push "$ECR_REGISTRY/$ECR_REPO_LOADER:$IMAGE_TAG";
      if [ "$CI_COMMIT_BRANCH" = "main" ]; then
        docker tag "$ECR_REGISTRY/$ECR_REPO_LOADER:$IMAGE_TAG" "$ECR_REGISTRY/$ECR_REPO_LOADER:latest";
        docker push "$ECR_REGISTRY/$ECR_REPO_LOADER:latest";
      fi
    - >
      set -e;
      echo "Updating Lambda function image…";
      aws lambda update-function-code
      --function-name "$LAMBDA_FUNCTION_NAME"
      --image-uri "$ECR_REGISTRY/$ECR_REPO_API:$IMAGE_TAG"
      --region "$AWS_DEFAULT_REGION"
      | jq -r '.LastUpdateStatus, .StateReason // empty'
    - |
      set -e
      echo "Waiting for Lambda to be Active (~2min max)…"
      for i in {1..24}; do
        STATUS=$(aws lambda get-function-configuration \
          --function-name "$LAMBDA_FUNCTION_NAME" \
          --region "$AWS_DEFAULT_REGION" | jq -r '.State')
        echo "Lambda state: $STATUS"
        [ "$STATUS" = "Active" ] && break
        sleep 5
      done
    - >
      set -e;
      echo "Submitting AWS Batch job…";
      aws batch submit-job
      --job-name "${BATCH_JOB_NAME:-fbc-refill-$CI_COMMIT_SHORT_SHA}"
      --job-queue "$BATCH_JOB_QUEUE"
      --job-definition "$BATCH_JOB_DEFINITION"
      --region "$AWS_DEFAULT_REGION"
      --container-overrides 'environment=[]'
      | tee batch_submit.json;
      echo "Batch job submitted: $(jq -r .jobId batch_submit.json)"
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
      when: on_success
    - if: '$CI_COMMIT_TAG'
      when: on_success
    - when: never

# ------------------------------
# Frontend: Selenium tests (kept disabled)
# ------------------------------
selenium_tests:
  stage: selenium_tests
  image: python:3.12-bullseye
  script:
    - apt-get update && apt-get install -y wget unzip xvfb libxi6 libgconf-2-4
    - pip install selenium
    - wget -q -O google-chrome.deb https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb
    - apt install -y ./google-chrome.deb
    - CHROME_VERSION=$(google-chrome --version | grep -oP '\d+\.\d+\.\d+')
    - wget -q https://chromedriver.storage.googleapis.com/$CHROME_VERSION/chromedriver_linux64.zip
    - unzip chromedriver_linux64.zip
    - mv chromedriver /usr/local/bin/
    - chmod +x /usr/local/bin/chromedriver
    - cd frontend/src/selenium_tests
    - python -m unittest discover -s . -p "*.py" -v
  dependencies:
    - deploy_website
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
      when: never    # flip to on_success when ready
    - when: never
