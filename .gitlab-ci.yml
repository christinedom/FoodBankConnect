stages:
  - build
  - deploy
  - backend_release
  - backend_test
  - postman_tests
  - selenium_tests
  - jest_tests

variables:
  REQUIREMENTS_FILE_UNIT: "fbc-load-db/requirements.txt"
  REQUIREMENTS_FILE_API:  "fbc-rest-api/requirements.txt"
  PYTEST_WORKDIR: ""
  PYTEST_TESTPATH: "tests"
  PYTEST_IGNORE: "frontend/src/selenium_tests"
  REPORT_DIR: "reports"
  PYTEST_JUNIT_XML: "$REPORT_DIR/pytest-report.xml"
  PYTEST_COVERAGE_XML: "$REPORT_DIR/coverage.xml"
  POSTMAN_COLLECTION: "tests/postman/collection.json"
  NEWMAN_JUNIT_XML: "$REPORT_DIR/newman-results.xml"
  API_APP_ENTRY: "fbc-rest-api/main.py"
  API_HEALTH_URL: "http://localhost:8080/health"
  COV_TARGET_DIR: "fbc-load-db"

build_react:
  stage: build
  image: node:20-bullseye
  script:
    - cd frontend
    - npm ci
    - CI=false npm run build
  artifacts:
    paths:
      - frontend/build
  rules:
    - if: '$FORCE_FRONTEND == "1"'
      when: on_success
    - changes:
        - frontend/**/*
        - frontend/.env*
        - package.json
        - package-lock.json
        - frontend/package.json
        - frontend/package-lock.json
      when: on_success
    - when: never

deploy_website:
  stage: deploy
  image:
    name: amazon/aws-cli
    entrypoint: [""]
  dependencies:
    - build_react
  script:
    - aws s3 sync frontend/build/ s3://$S3_BUCKET --delete
    - aws cloudfront create-invalidation --distribution-id $CLOUDFRONT_DIST_ID --paths "/*"
  rules:
    - if: '$FORCE_FRONTEND == "1" && $CI_COMMIT_BRANCH == "main"'
      when: on_success
    - if: '$CI_COMMIT_BRANCH == "main"'
      changes:
        - frontend/**/*
        - frontend/.env*
        - package.json
        - package-lock.json
        - frontend/package.json
        - frontend/package-lock.json
      when: on_success
    - when: never

backend_release:
  stage: backend_release
  image: docker:24.0.7
  needs: []
  services:
    - name: docker:24.0.7-dind
      alias: docker
      command: ["--tls=false","--mtu=1460"]
  allow_failure: true
  variables:
    DOCKER_HOST: "tcp://docker:2375"
    DOCKER_TLS_CERTDIR: ""
    AWS_DEFAULT_REGION: $AWS_DEFAULT_REGION
    AWS_ACCESS_KEY_ID: $AWS_ACCESS_KEY_ID
    AWS_SECRET_ACCESS_KEY: $AWS_SECRET_ACCESS_KEY
    ECR_REGISTRY: $ECR_REGISTRY
    ECR_REPO_API: $ECR_REPO_API
    ECR_REPO_LOADER: $ECR_REPO_LOADER
    IMAGE_TAG: $CI_COMMIT_SHORT_SHA
    LAMBDA_FUNCTION_NAME: $LAMBDA_FUNCTION_NAME
    BATCH_JOB_QUEUE: $BATCH_JOB_QUEUE
    BATCH_JOB_DEFINITION: $BATCH_JOB_DEFINITION
    BATCH_JOB_NAME: $BATCH_JOB_NAME
    API_CONTEXT: "."
    API_DOCKERFILE: "Dockerfile.api"
    LOADER_CONTEXT: "."
    LOADER_DOCKERFILE: "Dockerfile.loader"
  before_script:
    - apk add --no-cache curl bash jq aws-cli
    - aws --version
    - >
      aws ecr get-login-password --region "$AWS_DEFAULT_REGION" |
      docker login --username AWS --password-stdin "$ECR_REGISTRY"

  script:
    - >
      set -e;
      docker build -f "$API_DOCKERFILE" -t "$ECR_REGISTRY/$ECR_REPO_API:$IMAGE_TAG" "$API_CONTEXT";
      docker push "$ECR_REGISTRY/$ECR_REPO_API:$IMAGE_TAG";
      if [ "$CI_COMMIT_BRANCH" = "main" ]; then
        docker tag "$ECR_REGISTRY/$ECR_REPO_API:$IMAGE_TAG" "$ECR_REGISTRY/$ECR_REPO_API:latest";
        docker push "$ECR_REGISTRY/$ECR_REPO_API:latest";
      fi

    # - >
    #   set -e;
    #   docker build -f "$LOADER_DOCKERFILE" -t "$ECR_REGISTRY/$ECR_REPO_LOADER:$IMAGE_TAG" "$LOADER_CONTEXT";
    #   docker push "$ECR_REGISTRY/$ECR_REPO_LOADER:$IMAGE_TAG";
    #   if [ "$CI_COMMIT_BRANCH" = "main" ]; then
    #     docker tag "$ECR_REGISTRY/$ECR_REPO_LOADER:$IMAGE_TAG" "$ECR_REGISTRY/$ECR_REPO_LOADER:latest";
    #     docker push "$ECR_REGISTRY/$ECR_REPO_LOADER:latest";
    #   fi

    - >
      set -e;
      aws lambda update-function-code
      --function-name "$LAMBDA_FUNCTION_NAME"
      --image-uri "$ECR_REGISTRY/$ECR_REPO_API:$IMAGE_TAG"
      --region "$AWS_DEFAULT_REGION"
      | jq -r '.LastUpdateStatus, .StateReason // empty'

    - |
      set -e
      for i in {1..24}; do
        STATUS=$(aws lambda get-function-configuration \
          --function-name "$LAMBDA_FUNCTION_NAME" \
          --region "$AWS_DEFAULT_REGION" | jq -r '.State')
        [ "$STATUS" = "Active" ] && break
        sleep 5
      done

    # - >
    #   set -e;
    #   aws batch submit-job
    #   --job-name "${BATCH_JOB_NAME:-fbc-refill-$CI_COMMIT_SHORT_SHA}"
    #   --job-queue "$BATCH_JOB_QUEUE"
    #   --job-definition "$BATCH_JOB_DEFINITION"
    #   --region "$AWS_DEFAULT_REGION"
    #   --container-overrides 'environment=[]'
    #   | tee batch_submit.json;

  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
      when: on_success
    - if: '$CI_COMMIT_TAG'
      when: on_success
    - when: never

backend_unit_tests:
  stage: backend_test
  image: python:3.12-bullseye
  variables:
    PYTHONPATH: "fbc-rest-api"
  before_script:
    - pip install --upgrade pip
    - pip install -r "fbc-rest-api/requirements.txt"
    - pip install pytest
  script:
    - pytest -q --maxfail=1 --disable-warnings \
        --junitxml "$REPORT_DIR/pytest-report.xml" \
        tests/test_api_unit.py
  artifacts:
    when: always
    reports:
      junit: "$PYTEST_JUNIT_XML"
    paths:
      - "$PYTEST_JUNIT_XML"
  rules:
    - changes:
        - fbc-rest-api/**/*
        - tests/test_api_unit.py
      when: on_success
    - when: never

postman_tests:
  stage: postman_tests
  image: node:20-bullseye
  before_script:
    - npm install -g newman newman-reporter-junitfull
  script:
    - >
      newman run "$POSTMAN_COLLECTION"
      --reporters cli,junitfull
      --reporter-junitfull-export "$NEWMAN_JUNIT_XML"
      --env-var "url=http://localhost:8080"  # Override your {{url}} variable
  artifacts:
    when: always
    reports:
      junit: "$NEWMAN_JUNIT_XML"
    paths:
      - "$NEWMAN_JUNIT_XML"
  rules:
    - changes:
        - tests/postman/**/*
      when: on_success
    - when: never


selenium_tests:
  stage: selenium_tests
  image: python:3.12-bullseye
  before_script:
    - apt-get update && apt-get install -y wget unzip xvfb libxi6 libgconf-2-4 gnupg
    - wget -q -O - https://dl.google.com/linux/linux_signing_key.pub | apt-key add -
    - echo "deb [arch=amd64] http://dl.google.com/linux/chrome/deb/ stable main" > /etc/apt/sources.list.d/google-chrome.list
    - apt-get update && apt-get install -y google-chrome-stable
    - CHROME_VERSION=$(google-chrome --version | grep -oP '\d+\.\d+\.\d+')
    - wget -q "https://chromedriver.storage.googleapis.com/$CHROME_VERSION/chromedriver_linux64.zip"
    - unzip chromedriver_linux64.zip
    - mv chromedriver /usr/local/bin/
    - chmod +x /usr/local/bin/chromedriver
    - pip install -r "frontend/tests/requirements.txt"
    - pip install pytest
  script:
    - cd frontend/src/selenium_tests
    - python -m pytest -q --maxfail=1 --disable-warnings \
        --junitxml "$CI_PROJECT_DIR/reports/selenium-junit.xml"
  artifacts:
    when: always
    reports:
      junit: reports/selenium-junit.xml
    paths:
      - reports/selenium-junit.xml
  rules:
    - changes:
        - frontend/src/selenium_tests/**/*
        - frontend/tests/requirements.txt
      when: on_success
    - when: never



# ------------------------------------------------
# Frontend tests: Tests with Jest
# ------------------------------------------------
jest_tests:
  stage: jest_tests
  image: node:20-bullseye
  before_script:
    - cd frontend
  script:
    - npm ci
    - npm test -- --watchAll=false
  rules:
    - changes:
        - frontend/src/__tests__/**/*
        - frontend/package.json
        - frontend/package-lock.json
      when: on_success
    - when: never


# ------------------------------
# DB apply: run your loader directly (no Docker-in-Docker, no ECR/Batch)
# ------------------------------
apply_db:
  stage: backend_release
  image: python:3.12-slim
  variables:
    LOG_LEVEL: "INFO"
    TRUNCATE: "1"
    DRY_RUN: "0"
    SCRAPERS_DIR: "$CI_PROJECT_DIR/fbc-load-db/scrapers"
    DB_HOST: "fbc-psql-db.chyoag62glut.us-east-2.rds.amazonaws.com"
    DB_PORT: "5432"
    DB_NAME: "postgres"
    DB_USER: "postgres"
    DB_PASSWORD: "HardcoreHenry1!"
    DB_SCHEMA: "app"
    PYTHONUNBUFFERED: "1"
    PYTHONIOENCODING: "utf-8"
    PYTHONPATH: "$CI_PROJECT_DIR:$CI_PROJECT_DIR/fbc-load-db"
  before_script:
    - python -V
    - python -m pip install --upgrade pip
    - |
      if [ -f fbc-load-db/requirements.txt ]; then
        pip install --no-input -r fbc-load-db/requirements.txt
      elif [ -f requirements.txt ]; then
        pip install --no-input -r requirements.txt
      else
        pip install --no-input "sqlalchemy>=2" "psycopg2-binary>=2.9"
      fi
  script:
    - |
      set -euo pipefail

      # Check that files exist
      test -f "fbc-load-db/main.py" || { echo "ERROR: fbc-load-db/main.py not found."; exit 1; }
      test -f "fbc-load-db/scraper.py" || { echo "ERROR: fbc-load-db/scraper.py not found."; exit 1; }
      test -f "$SCRAPERS_DIR/scrapers.txt" || { echo "ERROR: scrapers.txt not found in $SCRAPERS_DIR"; exit 1; }

      # Check individual DB vars instead of DATABASE_URL
      for var in DB_HOST DB_PORT DB_NAME DB_USER DB_PASSWORD DB_SCHEMA; do
        if [ -z "${!var:-}" ]; then
          echo "ERROR: $var is not set in CI/CD variables."
          exit 2
        fi
      done

      echo "Running database apply using fbc-load-db/main.py..."
      python fbc-load-db/main.py
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
      when: on_success
    - when: manual
      allow_failure: false

apply_db_simulate:
  stage: backend_release
  image: python:3.12-slim
  variables:
    LOG_LEVEL: "INFO"
    SIMULATE_DUMMY: "1"            # Tells main.py to use dummy data
    TRUNCATE: "0"
    DRY_RUN: "1"
    SCRAPERS_DIR: "$CI_PROJECT_DIR/fbc-load-db/scrapers"
    PYTHONUNBUFFERED: "1"
    PYTHONIOENCODING: "utf-8"
    PYTHONPATH: "$CI_PROJECT_DIR:$CI_PROJECT_DIR/fbc-load-db"
  before_script:
    - python -V
    - python -m pip install --upgrade pip
    - |
      if [ -f fbc-load-db/requirements.txt ]; then
        pip install --no-input -r fbc-load-db/requirements.txt
      elif [ -f requirements.txt ]; then
        pip install --no-input -r requirements.txt
      else
        pip install --no-input "sqlalchemy>=2" "psycopg2-binary>=2.9"
      fi
  script:
    - |
      set -euo pipefail
      test -f "fbc-load-db/main.py" || { echo "ERROR: fbc-load-db/main.py not found."; exit 1; }
      echo "Running SIMULATION (dummy data, no scrapers, no DB writes)..."
      python fbc-load-db/main.py
  rules:
    # Run on any branch except main by default; also allow manual trigger
    - if: '$CI_COMMIT_BRANCH != "main"'
      when: on_success
    - when: manual
      allow_failure: false